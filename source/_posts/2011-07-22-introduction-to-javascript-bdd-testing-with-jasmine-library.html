--- 
layout: post
title: Introduction to JavaScript BDD testing with Jasmine library
tags: 
- jasmine
- javascript
- testing
status: publish
type: post
published: true
meta: 
  _edit_last: "1"
  _syntaxhighlighter_encoded: "1"
  dsq_thread_id: "374020783"
---
If we look at the developments in the software testing area, step beyond in evolution after <a title="Razvoj vođen testovima" href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> is, so called, <a title="Razvoj softvera vođen ponašanjem" href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> (Behavior Deriven Development). It is hard to describe BDD in couple of sentences. Excerpt taken from Wikipedia says:
<blockquote>BDD focuses on obtaining a clear understanding of desired software behaviour through discussion with stakeholders. It extends <a title="Test-driven development" href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> by writing test cases in a natural language that non-programmers can read. Behavior-driven developers use their native language to describe the purpose and benefit of their code. This allows the developers to focus on why the code should be created, rather than the technical details, and minimizes translation between the technical language in which the code is written and the domain language spoken by the business, users, stakeholders, project management, etc.</blockquote>
If this looks a bit complicated, in one sentence it would mean: <strong>BDD helps programmers and non-technical stakeholders understand each other better and develop software which will be the most representative model of the problem solved by writing the software  itself. </strong>
<h2>Jasmine: BDD for your JavaScript</h2>
<a title="Jasmine: BDD za vaš JavaScript" href="http://pivotal.github.com/jasmine/">Jasmine</a> is a library for BDD testing of your JavaScript. It offers range of possibilities to describe software functionalities by simple and descriptive tests, which is one of the basic principles of BDD based development. This way tests usually serve as the most accurate software documentation. More about Jasmine library on the <a title="Jasmine na GitHub" href="https://github.com/pivotal/jasmine">GitHub repository</a>.

After you download standalone Jasmine distribution from <a title="Nezavisna distribucija Jasmine biblioteke" href="http://pivotal.github.com/jasmine/download.html">here</a> you'll find in the archive all you need to write your first tests together with the example of your code organization. The most important fie is <strong>SpecRunner.html</strong> which, when run in browser, will execute tests and give you report about the state of the tests. SpecRunner.html is very simple and self explanatory. <strong>lib</strong> folder contains Jasmine library, <strong>src</strong> folder contains code to be tested and  <strong>spec</strong> folder contains actual software specifications as tests.

Further, I will implement simple object that can register multiple callback functions and call them with given data. Something like simple observer. I will always first write tests and then implement functionality to make tests pass.
<h2>Example of simple JavaScript observer with Jasmine tests</h2>
We start from the downloaded archive for standalone Jasmine library. We need to delete example code provided with the library to implement our own example.

[bash]cd jasmine-standalone # folder in which we extracted downloaded archive
rm src/*
rm spec/*[/bash]

Also, from <code>SpecRunner.html</code> file we delete references to just removed scripts. Therefore, part which includes them stays empty like this:

{% codeblock lang.js htmlscript="1" %}
...

  &lt;!-- include source files here... --&gt;

  &lt;!-- include spec files here... --&gt;

...
{% endcodeblock %}
<h3>First test</h3>
In TDD and BDD philosophy one rule is essential for success.
<blockquote>First you write the test which will at the beginning fail, then you implement code which should satisfy specification described by test. Then, you execute test and continue with implementation until test passes. When that happens you know that implementation is OK.</blockquote>
According to this we create file to place our tests in <code>spec/ObserverSpec.js</code> and we define first test to simply check existence of the observer object.

{% codeblock lang.js %}
describe(&quot;rs.ji.observer&quot;, function () {

    it(&quot;should be present in the global namespace&quot;, function () {
        expect(rs.ji.observer).toBeDefined();
    });

});
{% endcodeblock %}

And we add this specification to <code>SpecRunner.html</code> to execute it:

[html]
&lt;!-- include spec files here... --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;spec/ObserverSpec.js&quot;&gt;&lt;/script&gt;
[/html]

If we now open <code>SpecRunner.html</code> in some browser (i.e. Google Chrome) we will see one failing test.

It is important to take a look in how our test looks like. If you read the test you'll see how descriptive it is and how with simple words expresses how our code should behave, although example is very simple. Here it takes some creativity of the developer to make tests really valuable but more than that is important that developer have deep understanding of the dictionary and terminology of the domain for which software is developed because understanding of the domain should be heavily embedded in the test definitions.

Next step is to implement the code which will satisfy test. We will create file <code>src/observer.js</code>

{% codeblock lang.js %}
// defining so called namespace objects so I can namespace observer into
// rs.ji.observer
var rs = {};
rs.ji = {};

// observer implementation
rs.ji.observer = {};
{% endcodeblock %}

And we will add it to <code>SpecRunner.html</code>:

[html]
&lt;!-- include source files here... --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;src/observer.js&quot;&gt;&lt;/script&gt;
[/html]

If we run <code>SpecRunner.html</code> again, we can see that our test passes, it is green :)
<h3>Rest of implementation</h3>
Now, when we know for the principle  <strong>"First failing test, then implementation"</strong> we can add new functionalities to our simple example. We add next test:

{% codeblock lang.js %}
    it(&quot;should be able to register callback function&quot;, function () {
        // define function to be placed into the observer register
        function callback() { return null; }
        rs.ji.observer.register(callback);
        var callbacks = rs.ji.observer.getCallbacks();
        expect(callbacks.length).toBe(1);
        expect(callbacks[0]).toBe(callback);
    });
{% endcodeblock %}

And implementation that makes this test pass:

{% codeblock lang.js %}
rs.ji.observer = {
    callbacks: [],
    register: function (callback) {
        this.callbacks.push(callback);
    },
    getCallbacks: function () {
        return this.callbacks;
    }
};
{% endcodeblock %}

We want to check if we can register multiple callbacks. This functionality should be supported already, but we write test to confirm this:

{% codeblock lang.js %}
    // before every test we reset array of callbacks
    beforeEach(function () {
        rs.ji.observer.callbacks = [];
    });

    it(&quot;should be able to register multiple callbacks&quot;, function () {
        function callback1() { return null; }
        function callback2() { return null; }
        rs.ji.observer.register(callback1);
        rs.ji.observer.register(callback2);
        var callbacks = rs.ji.observer.getCallbacks();
        expect(callbacks.length).toBe(2);
        expect(callbacks[0]).toBe(callback1);
        expect(callbacks[1]).toBe(callback2);
    });
{% endcodeblock %}

Programmers often use <code>print, echo</code> and friends to test code for certain functionalities. That takes time as for writing a test, but from other side tests are possible to be executed all the time after this initial check is done even when we move to implement something else.

If we run <code>SpecRunner.html</code> in browser, all tests should pass.

Last thing our observer should do to satisfy its basic purpose is to update callback functions with some new information. That means it should be able to call them with some data. To define this functionality we write new test:

{% codeblock lang.js %}
    it(&quot;should provide update method to execute all callbacks with provided data&quot;, function () {
        window.callback1 = function () { return null; }
        window.callback2 = function () { return null; }
        spyOn(window, 'callback1');
        spyOn(window, 'callback2');
        rs.ji.observer.register(window.callback1);
        rs.ji.observer.register(window.callback2);
        rs.ji.observer.update(&quot;data string&quot;);
        expect(window.callback1).toHaveBeenCalledWith(&quot;data string&quot;);
        expect(window.callback2).toHaveBeenCalledWith(&quot;data string&quot;);
    });
{% endcodeblock %}

Here we use some advanced techniques of <a title="Jasmine špijuniranje metoda" href="https://github.com/pivotal/jasmine/wiki/Spies">spying on methods</a> (SpyOn) in order to see if some method is called while other is executed.

As a helper, we will add <a title="jQuery biblioteka" href="http://code.jquery.com/jquery-1.6.2.min.js">jQuery library</a> to <code>src/jquery.js</code> location and add it to <code>SpecRunner.html</code> file:

[html highlight="2"]
&lt;!-- include source files here... --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;src/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;src/observer.js&quot;&gt;&lt;/script&gt;
[/html]

And we implement code to satisfy the test:

{% codeblock lang.js %}
// observer implementation
rs.ji.observer = {
    callbacks: [],
    register: function (callback) {
        this.callbacks.push(callback);
    },
    getCallbacks: function () {
        return this.callbacks;
    },

    // added update method to inform registered callbacks
    // uses jQuery to iterate over the array
    update: function(data) {
        $.each(this.callbacks, function (i, callback) {
            callback.call(null, data); // call every callback with provided data
        });
    }
};
{% endcodeblock %}
<h2>Complete picutre</h2>
That is it, now we have full implementation of simple observer with tests that can pretty clearly describe functionalities of the software we developed and they can as well prove in every time that needed functionalities are working OK by executing them in the browser (or different browsers to see if they will work in all of them).

Complete files:

{% codeblock lang:js %}
describe(&quot;rs.ji.observer&quot;, function () {

    beforeEach(function () {
        rs.ji.observer.callbacks = [];
    });

    it(&quot;should be present in the global namespace&quot;, function () {
        expect(rs.ji.observer).toBeDefined();
    });

    it(&quot;should be able to register callback function&quot;, function () {
        // define anonymous function to be placed into the observer register
        function callback() { return null; }
        rs.ji.observer.register(callback);
        var callbacks = rs.ji.observer.getCallbacks();
        expect(callbacks.length).toBe(1);
        expect(callbacks[0]).toBe(callback); // so we need to have first funtion in registered callbacks
    });

    it(&quot;should be able to register multiple callbacks&quot;, function () {
        function callback1() { return null; }
        function callback2() { return null; }
        rs.ji.observer.register(callback1);
        rs.ji.observer.register(callback2);
        var callbacks = rs.ji.observer.getCallbacks();
        expect(callbacks.length).toBe(2);
        expect(callbacks[0]).toBe(callback1);
        expect(callbacks[1]).toBe(callback2);
    });

    it(&quot;should provide update method to execute all callbacks with provided data&quot;, function () {
        window.callback1 = function () { return null; }
        window.callback2 = function () { return null; }
        spyOn(window, 'callback1');
        spyOn(window, 'callback2');
        rs.ji.observer.register(window.callback1);
        rs.ji.observer.register(window.callback2);
        rs.ji.observer.update(&quot;data string&quot;);
        expect(window.callback1).toHaveBeenCalledWith(&quot;data string&quot;);
        expect(window.callback2).toHaveBeenCalledWith(&quot;data string&quot;);
    });
});
{% endcodeblock %}
{% codeblock lang.js %}
// defining so called namespace objects so I can namespace observer into
// rs.ji.observer
var rs = {};
rs.ji = {};

// observer implementation
rs.ji.observer = {
    callbacks: [],
    register: function (callback) {
        this.callbacks.push(callback);
    },
    getCallbacks: function () {
        return this.callbacks;
    },
    update: function(data) {
        $.each(this.callbacks, function (i, callback) {
            callback.call(null, data);
        });
    }

};
{% endcodeblock %} 
